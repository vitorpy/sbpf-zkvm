{"id":"sbpf0-2f33","content_hash":"033d2b1c10520b128b9a31853b5e4efc370a87a596b93c609638912ed8bda7eb","title":"End-to-End Demo","description":"Integrate all components into working demonstration that proves counter program execution. Creates complete pipeline from BPF bytecode to verified proof with clear success/failure reporting.","design":"Build demo.rs that loads counter bytecode, traces execution, generates circuit, creates proof, and verifies it. Include detailed logging and success reporting. Document the complete flow.","acceptance_criteria":"- [ ] demo.rs integrates bpf-tracer + zk-circuits + prover\n- [ ] Loads counter-program.so bytecode\n- [ ] Traces execution and prints instruction count\n- [ ] Generates circuit and prints constraint count\n- [ ] Creates and verifies proof successfully\n- [ ] Prints clear success message with initialâ†’final values\n- [ ] User documentation explains demo workflow","status":"open","priority":2,"issue_type":"epic","created_at":"2025-11-12T20:55:47.272509704+01:00","updated_at":"2025-11-12T20:55:47.272509704+01:00","dependencies":[{"issue_id":"sbpf0-2f33","depends_on_id":"sbpf0-9534","type":"blocks","created_at":"2025-11-12T20:59:05.468274353+01:00","created_by":"vitorpy"},{"issue_id":"sbpf0-2f33","depends_on_id":"sbpf0-402e","type":"blocks","created_at":"2025-11-12T20:59:10.495891932+01:00","created_by":"vitorpy"}]}
{"id":"sbpf0-402e","content_hash":"2d853d8624b781ee2109eae2839b6f6dd6bc949cf03b632ff434165b8c2dfb0d","title":"Counter Program Example","description":"Create minimal no_std Solana BPF program that increments a counter value. Pure Rust implementation without solana-sdk dependencies, compiled to BPF bytecode for use as test/demo program.","design":"Write no_std Rust with manual register manipulation, implement counter logic (read u64, increment, write back), configure BPF build target (bpfel-unknown-unknown), generate .so ELF binary.","acceptance_criteria":"- [ ] src/lib.rs with no_std counter implementation\n- [ ] No solana-sdk dependencies in Cargo.toml\n- [ ] Compiles to bpfel-unknown-unknown target\n- [ ] Counter logic: read from memory, increment, write back\n- [ ] Generates valid counter-program.so binary\n- [ ] Build instructions documented","status":"open","priority":0,"issue_type":"epic","created_at":"2025-11-12T20:55:33.862883126+01:00","updated_at":"2025-11-12T20:55:33.862883126+01:00","dependencies":[{"issue_id":"sbpf0-402e","depends_on_id":"sbpf0-4a41","type":"blocks","created_at":"2025-11-12T20:58:40.952354874+01:00","created_by":"vitorpy"}]}
{"id":"sbpf0-4a41","content_hash":"69a054061519a9c13aeb46ec110074a939fd5df0df54dda3b498c68ebb787848","title":"Project Setup \u0026 Dependencies","description":"Initialize Rust workspace, add git submodules (sbpf, halo2-lib), configure build system, and set up documentation structure. This establishes the foundation for the entire zkVM project.","design":"Create workspace Cargo.toml with proper dependency resolution, add submodules in deps/ directory, configure rust-toolchain.toml for BPF target support, set up justfile/Makefile for automation.","acceptance_criteria":"- [ ] Workspace Cargo.toml configured with all members\n- [ ] Git submodules added and initialized (sbpf, halo2-lib)\n- [ ] rust-toolchain.toml configured with bpfel-unknown-unknown target\n- [ ] Build automation (justfile) with init, build, test, demo, clean targets\n- [ ] README.md with setup instructions\n- [ ] Project compiles successfully","status":"in_progress","priority":0,"issue_type":"epic","created_at":"2025-11-12T20:54:34.980280514+01:00","updated_at":"2025-11-12T21:00:06.014560246+01:00"}
{"id":"sbpf0-9534","content_hash":"429c18679441f3ceb228dbbfbb17df49452170a5899ac47ced92e97bc05709e0","title":"Proof System Integration","description":"Connect execution traces to ZK circuits and implement complete proof generation/verification pipeline. Orchestrates witness generation from traces, proof creation via Halo2, and verification with public inputs.","design":"Implement witness generation from ExecutionTrace, create Halo2 proving/verifying key management, build high-level API (prove_execution, verify_execution), define PublicInputs structure with state commitments.","acceptance_criteria":"- [ ] generate_witness() converts trace to circuit witness\n- [ ] create_proof() generates valid Halo2 proof\n- [ ] verify_proof() validates proofs with public inputs\n- [ ] PublicInputs structure with initial/final state hashes\n- [ ] Proving and verifying keys generated correctly\n- [ ] End-to-end proof generation works","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-12T20:55:20.559043848+01:00","updated_at":"2025-11-12T20:55:20.559043848+01:00","dependencies":[{"issue_id":"sbpf0-9534","depends_on_id":"sbpf0-ccd2","type":"blocks","created_at":"2025-11-12T20:58:50.872076237+01:00","created_by":"vitorpy"},{"issue_id":"sbpf0-9534","depends_on_id":"sbpf0-aa44","type":"blocks","created_at":"2025-11-12T20:58:55.903310428+01:00","created_by":"vitorpy"}]}
{"id":"sbpf0-aa44","content_hash":"b1fd8f7a17e632f072d118f9e27783e2c309ae9b4fe864ec7836a50ae0417520","title":"ZK Circuit Design","description":"Implement zero-knowledge circuits for BPF instruction verification using Halo2. Create instruction chips for minimal BPF subset (ALU ops, memory ops, exit) and build counter program circuit with public input/output commitments.","design":"Use halo2-lib (Axiom fork) with FlexGateChip for arithmetic, implement BpfInstructionChip trait, create instruction-specific chips (ALU64_ADD_IMM, ALU64_ADD_REG, STW, LDW, EXIT), build CounterCircuit with trace verification constraints.","acceptance_criteria":"- [ ] BpfInstructionChip trait defined with synthesize()\n- [ ] Minimal instruction chips implemented (5 instructions)\n- [ ] CounterCircuit with public inputs (initial_hash, final_hash)\n- [ ] Constraints verify instruction execution correctness\n- [ ] Circuit has \u003c100k constraints\n- [ ] Tests verify circuit soundness","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-12T20:55:07.430999564+01:00","updated_at":"2025-11-12T20:55:07.430999564+01:00","dependencies":[{"issue_id":"sbpf0-aa44","depends_on_id":"sbpf0-4a41","type":"blocks","created_at":"2025-11-12T20:58:35.92369169+01:00","created_by":"vitorpy"}]}
{"id":"sbpf0-ccd2","content_hash":"0fd0d3695220b2e0cebd9762afc1ad7b65fd80407fe3dc079a5c52a6cf6e8c99","title":"BPF Tracer Implementation","description":"Build execution trace capture system for Solana BPF programs. Wraps solana-sbpf VM to instrument and record complete execution traces including register state, memory operations, and instruction flow.","design":"Wrap solana-sbpf VM with custom instrumentation, define ExecutionTrace and InstructionTrace structures, implement trace_program() function with full register and memory tracking, add syscall handlers for basic operations.","acceptance_criteria":"- [ ] ExecutionTrace data structure defined\n- [ ] InstructionTrace captures PC, instruction bytes, register state\n- [ ] Memory operations tracked (address, value, read/write)\n- [ ] trace_program() function executes and captures traces\n- [ ] Tests verify trace accuracy for basic BPF programs\n- [ ] Documentation explains trace format","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-12T20:54:52.640117072+01:00","updated_at":"2025-11-12T20:54:52.640117072+01:00","dependencies":[{"issue_id":"sbpf0-ccd2","depends_on_id":"sbpf0-4a41","type":"blocks","created_at":"2025-11-12T20:58:30.893054446+01:00","created_by":"vitorpy"}]}
